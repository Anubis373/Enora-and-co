<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NIRD - The Snake Matrix</title>
    <link rel="stylesheet" href="mystyle.css"> 
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body {
            /* Utilisation des variables de mystyle.css, mais en adaptant pour le jeu */
            background-color: var(--dark);
            color: #0F0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            flex-direction: column;
            font-family: 'Share Tech Mono', monospace;
            padding: 20px;
        }

        .snake-matrix-game-area {
            background-color: var(--dark);
            border: 2px solid #00FF00;
            padding: 1rem;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            max-width: 550px;
            margin: 20px auto;
        }

        .snake-matrix-game-area h1 {
            color: #00FF00;
            text-shadow: 0 0 5px #00FF00;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: #008000;
            margin-bottom: 1rem;
        }

        #game-wrapper {
            position: relative;
            width: 512px;
            height: 512px;
            margin: 1rem 0;
            border: 1px solid #00FF00;
            overflow: hidden;
        }

        #gc {
            display: block;
            background-color: #000;
        }

        #matrix-hud {
            position: absolute;
            top: 5px;
            right: 10px;
            text-align: right;
            font-size: 1.5rem;
        }

        .hud-label {
            display: block;
            font-size: 0.8rem;
            color: #008000;
        }

        #status-effects {
            position: absolute;
            bottom: 5px;
            left: 10px;
            font-size: 0.9rem;
        }

        .status-msg {
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from { opacity: 0.8; }
            to { opacity: 1.0; }
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                to bottom,
                transparent 0px,
                transparent 1px,
                rgba(0, 0, 0, 0.2) 2px,
                rgba(0, 0, 0, 0.2) 3px
            );
            opacity: 0.3;
        }

        /* --- STYLES MODIFIÉS POUR L'ÉCRAN BLEU DE LA MORT (BSOD) --- */
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0078d7; /* Bleu classique Windows */
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center; /* Centrage des éléments */
            padding: 40px;
            box-sizing: border-box;
            font-family: 'Segoe UI', sans-serif; /* Police typique BSOD */
            z-index: 10;
            text-align: center;
        }

        .sad-face {
            font-size: 80px;
            margin-bottom: 10px;
            line-height: 1;
        }

        #game-over-screen h2 {
            font-size: 24px;
            font-weight: normal;
            margin: 0 0 20px 0;
            text-shadow: none;
            line-height: 1.3;
        }

        #game-over-screen div[style] {
            font-size: 14px; 
            opacity: 0.8; 
            margin-top: 20px;
            font-family: monospace; /* Pour le message d'erreur */
        }
        
        #game-over-screen button {
            margin-top: 30px;
            padding: 10px 25px;
            font-family: 'Share Tech Mono', monospace; /* Garder l'esthétique matrix pour le bouton */
            font-size: 24px;
            background-color: #000;
            color: #0F0;
            border: 2px solid #0F0;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            transition: all 0.2s;
        }

        #game-over-screen button:hover {
            background-color: #0F0;
            color: black;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
        }
        /* --- FIN STYLES MODIFIÉS --- */

        #legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .legend-item {
            border: 1px solid #008000;
            padding: 5px 10px;
        }

        .back-button {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: var(--primary);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            transition: background-color 0.2s;
        }

        .back-button:hover {
            background-color: #d35400;
        }
    </style>
</head>
<body>

    <div class="snake-matrix-game-area">
        <h1>THE SNAKE MATRIX</h1>
        <div class="subtitle">System Override: Linux vs Win32</div>

        <div id="game-wrapper">
            <canvas id="gc" width="512" height="512"></canvas>
            
            <div id="matrix-hud">
                <span class="hud-label">DATA COLLECTED</span>
                <span id="matrix-score-val">0</span>
            </div>

            <div id="status-effects"></div>
            <div class="scanlines"></div>

            <div id="game-over-screen">
                <div class="sad-face">:(</div>
                <h2>SYSTEM FAILURE.<br>Final Data: <span id="final-score">0</span></h2>
                <div style="font-size:14px; opacity:0.8; margin-top:20px;">FATAL_ERROR: 0x0000DEAD<br>Process "Tux" terminated unexpectedly.</div>
                <button onclick="window.initSnakeMatrix()">REBOOT SYSTEM</button>
            </div>
        </div>
        
        <div id="legend">
            <div class="legend-item"><span style="color:#00ffff">C:</span>Slow</div>
            <div class="legend-item"><span style="color:#ffff00">P:</span>Cut Tail (-Score)</div>
            <div class="legend-item"><span style="color:#ff0000">B:</span>Fast</div>
            <div class="legend-item"><span style="color:#ff00ff">V:</span>Virus (Reverse)</div>
        </div>
    </div>
    
    <a href="main.html" class="back-button">Retour au Clicker</a>

    <script>
        window.initSnakeMatrix = function() {
            const canvas = document.getElementById('gc');
            const ctx = canvas.getContext('2d');
            const matrixScoreEl = document.getElementById('matrix-score-val');
            const gameOverScreen = document.getElementById('game-over-screen');
            const finalScoreSpan = document.getElementById('final-score'); // NOUVELLE RÉFÉRENCE
            const statusEffectsEl = document.getElementById('status-effects');

            const tileCount = 16; 
            const gridSize = canvas.width / tileCount;
            
            let headX, headY, velocityX, velocityY, appleX, appleY;
            let trail = [];
            let tailLength;
            let score;
            let isGameRunning = false;
            let inputQueue = [];

            let lastTime = 0;
            let dropCounter = 0;
            let dropInterval = 200;
            let baseSpeed = 200; 

            let particles = [];
            let floatingTexts = [];
            let activeItems = []; 
            let itemsTimer = 0;   
            
            let isControlsReversed = false;
            let reverseTimeout = null;

            const katakana = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const characters = katakana.split('');
            const fontSize = 14;
            const columns = canvas.width / fontSize;
            const drops = []; 
            for(let x = 0; x < columns; x++) drops[x] = Math.random() * canvas.height;

            const ITEM_TYPES = {
                SLOW: { color: '#00ffff', label: 'C', name: 'COFFEE (Slow)', duration: 0 },
                CUT:  { color: '#ffff00', label: 'P', name: 'PURGE (Cut)', duration: 0 },
                FAST: { color: '#ff0000', label: 'B', name: 'BLOATWARE (Fast)', duration: 0 },
                VIRUS:{ color: '#ff00ff', label: 'V', name: 'VIRUS (Reverse)', duration: 5000 }
            };

            if (document.removeEventListener) {
                document.removeEventListener("keydown", keyPush);
            }
            document.addEventListener("keydown", keyPush);
            
            resetGame(); 

            function resetGame() {
                headX = Math.floor(tileCount / 2);
                headY = Math.floor(tileCount / 2);
                velocityX = 0; velocityY = 0;
                trail = [];
                tailLength = 4;
                score = 0;
                matrixScoreEl.innerText = "0";
                inputQueue = [];
                
                baseSpeed = 200;
                dropInterval = baseSpeed;
                
                particles = [];
                floatingTexts = [];
                activeItems = [];
                itemsTimer = 0;
                
                isControlsReversed = false;
                clearTimeout(reverseTimeout);
                updateStatusUI();

                for(let i=0; i<tailLength; i++) trail.push({x: headX, y: headY});

                placeApple();
                gameOverScreen.style.display = "none";
                isGameRunning = true;
                
                lastTime = 0;
                dropCounter = 0;
                if (window.gameRAF) {
                    cancelAnimationFrame(window.gameRAF);
                }
                window.gameRAF = requestAnimationFrame(gameLoop);
            }

            function gameLoop(time = 0) {
                if (!isGameRunning) return;
                const deltaTime = time - lastTime;
                lastTime = time;
                dropCounter += deltaTime;

                manageItems(deltaTime);

                if (dropCounter > dropInterval) {
                    updateSnake();
                    dropCounter = 0;
                }

                draw();
                window.gameRAF = requestAnimationFrame(gameLoop);
            }

            function manageItems(dt) {
                itemsTimer += dt;
                
                if (itemsTimer > 4000 && activeItems.length < 2) {
                    itemsTimer = 0;
                    if(Math.random() > 0.3) { 
                        spawnItem();
                    }
                }

                for (let i = 0; i < activeItems.length; i++) {
                    activeItems[i].timeLeft -= dt;
                    if (activeItems[i].timeLeft <= 0) {
                        activeItems.splice(i, 1);
                        i--; 
                    }
                }
            }

            function spawnItem() {
                const keys = Object.keys(ITEM_TYPES);
                const randomKey = keys[Math.floor(Math.random() * keys.length)];
                const type = ITEM_TYPES[randomKey];

                let valid = false;
                let ix, iy;
                while(!valid) {
                    ix = Math.floor(Math.random() * tileCount);
                    iy = Math.floor(Math.random() * tileCount);
                    valid = true;
                    for(let t of trail) if(t.x === ix && t.y === iy) valid = false;
                    if(ix === appleX && iy === appleY) valid = false;
                    for(let it of activeItems) if(it.x === ix && it.y === iy) valid = false;
                }

                activeItems.push({ 
                    x: ix, 
                    y: iy, 
                    type: type, 
                    typeKey: randomKey,
                    timeLeft: 8000
                });
            }

            function updateSnake() {
                if (inputQueue.length > 0) {
                    let nextMove = inputQueue.shift();
                    velocityX = nextMove.x;
                    velocityY = nextMove.y;
                }

                headX += velocityX;
                headY += velocityY;

                if (headX < 0 || headX >= tileCount || headY < 0 || headY >= tileCount) {
                    triggerGameOver();
                    return;
                }

                if (velocityX !== 0 || velocityY !== 0) {
                    for (let i = 0; i < trail.length - 1; i++) {
                        if (trail[i].x === headX && trail[i].y === headY) {
                            triggerGameOver();
                            return;
                        }
                    }
                }

                for (let i = 0; i < activeItems.length; i++) {
                    let item = activeItems[i];
                    if (headX === item.x && headY === item.y) {
                        applyItemEffect(item);
                        activeItems.splice(i, 1);
                        i--;
                    }
                }

                trail.push({ x: headX, y: headY });
                while (trail.length > tailLength) {
                    trail.shift();
                }

                if (headX === appleX && headY === appleY) {
                    tailLength++;
                    score += 10;
                    glitchScore(score);
                    if (baseSpeed > 60) baseSpeed -= 4;
                    dropInterval = baseSpeed;

                    createExplosion(appleX, appleY, "#00FF00");
                    createFloatingText(appleX, appleY, "WIN32_DEL");
                    placeApple();
                }
            }

            function applyItemEffect(item) {
                const type = item.type;
                
                createFloatingText(headX, headY, type.name, type.color);
                createExplosion(headX, headY, type.color);

                switch(item.typeKey) {
                    case 'SLOW':
                        dropInterval += 100; 
                        if(dropInterval > 400) dropInterval = 400;
                        break;
                    case 'CUT': 
                        let cutAmount = Math.floor(tailLength / 2);
                        if (tailLength - cutAmount < 3) cutAmount = tailLength - 3;
                        if (cutAmount > 0) {
                            tailLength -= cutAmount;
                            trail.splice(0, cutAmount); 
                            
                            let pointsLost = cutAmount * 10;
                            score -= pointsLost;
                            if(score < 0) score = 0;
                            
                            matrixScoreEl.innerText = score;
                            
                            createFloatingText(headX, headY - 1, "-" + pointsLost, "#ffff00");
                        }
                        break;
                    case 'FAST': 
                        dropInterval -= 80;
                        if(dropInterval < 40) dropInterval = 40;
                        break;
                    case 'VIRUS':
                        triggerReverseControls();
                        break;
                }
            }

            function triggerReverseControls() {
                isControlsReversed = true;
                updateStatusUI();
                clearTimeout(reverseTimeout);
                reverseTimeout = setTimeout(() => {
                    isControlsReversed = false;
                    updateStatusUI();
                    createFloatingText(headX, headY, "ANTIVIRUS DONE", "#FFFFFF");
                }, 5000);
            }

            function updateStatusUI() {
                statusEffectsEl.innerHTML = "";
                if(isControlsReversed) {
                    const div = document.createElement("div");
                    div.className = "status-msg";
                    div.style.color = "#ff00ff";
                    div.innerText = "⚠ CONTROLS REVERSED";
                    statusEffectsEl.appendChild(div);
                }
            }

            function glitchScore(target) {
                let iteration = 0;
                const interval = setInterval(() => {
                    matrixScoreEl.innerText = Math.floor(Math.random() * (target + 100));
                    iteration++;
                    if (iteration >= 5) {
                        clearInterval(interval);
                        matrixScoreEl.innerText = target;
                    }
                }, 30);
            }

            function draw() {
                ctx.fillStyle = "rgba(0, 0, 0, 0.1)"; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#003300"; ctx.font = fontSize + "px monospace";
                for(let i = 0; i < drops.length; i++) {
                    if(Math.random() > 0.98) {
                       const text = characters[Math.floor(Math.random() * characters.length)];
                       ctx.fillStyle = (Math.random() > 0.9) ? "#00FF00" : "#004400";
                       ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    }
                    if(drops[i] * fontSize > canvas.height && Math.random() > 0.98) drops[i] = 0;
                    drops[i]++;
                }

                ctx.strokeStyle = "rgba(0, 255, 0, 0.1)"; ctx.lineWidth = 1;
                for(let i=0; i<tileCount; i++) {
                    ctx.beginPath(); ctx.moveTo(i*gridSize, 0); ctx.lineTo(i*gridSize, canvas.height); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, i*gridSize); ctx.lineTo(canvas.width, i*gridSize); ctx.stroke();
                }

                ctx.font = "16px 'Share Tech Mono', monospace"; ctx.fillStyle = "#00FF00"; ctx.textAlign = "left";
                ctx.fillText("root@matrix:~/sys$ ./snake_v2.0", 10, 25);

                for(let item of activeItems) {
                    ctx.globalAlpha = 1.0;
                    if (item.timeLeft < 3000) {
                        if (Math.floor(item.timeLeft / 200) % 2 === 0) ctx.globalAlpha = 0.3;
                    }
                    drawItem(item.x * gridSize, item.y * gridSize, gridSize, item.type);
                    ctx.globalAlpha = 1.0; 
                }

                drawWindowsLogo(appleX * gridSize, appleY * gridSize, gridSize);
                for (let i = 0; i < trail.length; i++) drawTux(trail[i].x * gridSize, trail[i].y * gridSize, gridSize);
                
                updateAndDrawParticles();
            }

            function drawItem(x, y, size, type) {
                ctx.shadowBlur = 15; ctx.shadowColor = type.color;
                ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(x + 2, y + 2, size - 4, size - 4);
                ctx.strokeStyle = type.color; ctx.lineWidth = 2; ctx.strokeRect(x + 4, y + 4, size - 8, size - 8);
                ctx.fillStyle = type.color; ctx.font = "bold " + (size*0.7) + "px monospace";
                ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(type.label, x + size/2, y + size/2 + 2);
                ctx.shadowBlur = 0; 
            }

            function updateAndDrawParticles() {
                 for (let i = particles.length - 1; i >= 0; i--) {
                    let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.03;
                    if (p.life <= 0) particles.splice(i, 1);
                    else { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0; }
                 }
                 for (let i = floatingTexts.length - 1; i >= 0; i--) {
                    let ft = floatingTexts[i]; ft.y += ft.vy; ft.life -= 0.015;
                    if (ft.life <= 0) floatingTexts.splice(i, 1);
                    else { ctx.globalAlpha = ft.life; ctx.font = "bold 16px monospace"; ctx.fillStyle = ft.color; ctx.textAlign = "center"; ctx.shadowBlur = 5; ctx.shadowColor = ft.color; ctx.fillText(ft.text, ft.x, ft.y); ctx.shadowBlur = 0; ctx.globalAlpha = 1.0; }
                 }
            }

            function createExplosion(x, y, color) {
                const cx = x * gridSize + gridSize/2; const cy = y * gridSize + gridSize/2;
                for(let i=0; i<10; i++) particles.push({ x: cx, y: cy, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12, life: 1.0, color: color, size: Math.random()*5+2 });
            }
            function createFloatingText(x, y, text, color="#0F0") {
                const cx = x * gridSize + gridSize/2; const cy = y * gridSize;
                floatingTexts.push({ x: cx, y: cy, text: text, life: 1.0, vy: -1.0, color: color });
            }

            function drawTux(x, y, size) {
                const cx = x + size/2; const cy = y + size/2; const s = size;
                if(isControlsReversed) ctx.shadowColor = "#ff00ff"; else ctx.shadowColor = "transparent";
                ctx.shadowBlur = isControlsReversed ? 10 : 0;
                ctx.fillStyle = "#FFAA00"; ctx.beginPath(); ctx.ellipse(cx - s*0.2, cy + s*0.35, s*0.15, s*0.1, 0, 0, Math.PI*2); ctx.ellipse(cx + s*0.2, cy + s*0.35, s*0.15, s*0.1, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#000"; ctx.beginPath(); ctx.ellipse(cx, cy, s*0.38, s*0.42, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#FFF"; ctx.beginPath(); ctx.ellipse(cx, cy + s*0.1, s*0.22, s*0.28, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#FFF"; ctx.beginPath(); ctx.arc(cx - s*0.12, cy - s*0.15, s*0.09, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx + s*0.12, cy - s*0.15, s*0.09, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(cx - s*0.1, cy - s*0.15, s*0.03, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx + s*0.14, cy - s*0.15, s*0.03, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#FF8800"; ctx.beginPath(); ctx.ellipse(cx, cy - s*0.02, s*0.1, s*0.04, 0, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0; 
            }
            
            function drawWindowsLogo(x, y, size) {
                let pad = size * 0.15; let half = (size / 2) - pad; let offset = pad; 
                ctx.fillStyle = "#f35325"; ctx.fillRect(x + offset, y + offset, half, half);
                ctx.fillStyle = "#81bc06"; ctx.fillRect(x + half + pad, y + offset, half, half);
                ctx.fillStyle = "#05a6f0"; ctx.fillRect(x + offset, y + half + pad, half, half);
                ctx.fillStyle = "#ffba08"; ctx.fillRect(x + half + pad, y + half + pad, half, half);
            }

            // FONCTION DE FIN DE PARTIE MISE À JOUR
            function triggerGameOver() { 
                isGameRunning = false; 
                finalScoreSpan.innerText = score; // Utilise le nouvel ID pour afficher le score
                gameOverScreen.style.display = "flex"; 
            }

            function placeApple() {
                let valid = false;
                while(!valid) { appleX = Math.floor(Math.random() * tileCount); appleY = Math.floor(Math.random() * tileCount); valid = true; for(let t of trail) { if(t.x === appleX && t.y === appleY) valid = false; } }
            }

            function keyPush(evt) {
                if (!isGameRunning) return;

                let currentVx = velocityX;
                let currentVy = velocityY;
                if (inputQueue.length > 0) {
                    const lastMove = inputQueue[inputQueue.length - 1];
                    currentVx = lastMove.x; currentVy = lastMove.y;
                }

                let nextVx = 0; let nextVy = 0;
                let key = evt.keyCode;

                if (isControlsReversed) {
                    if (key === 37) key = 39;
                    else if (key === 39) key = 37;
                    else if (key === 38) key = 40;
                    else if (key === 40) key = 38;
                }

                switch(key) {
                    case 37: nextVx = -1; nextVy = 0; break; 
                    case 38: nextVx = 0; nextVy = -1; break; 
                    case 39: nextVx = 1; nextVy = 0; break; 
                    case 40: nextVx = 0; nextVy = 1; break; 
                    default: return;
                }

                if (currentVx !== 0 && nextVx === -currentVx) return;
                if (currentVy !== 0 && nextVy === -currentVy) return;

                if (inputQueue.length < 2) inputQueue.push({x: nextVx, y: nextVy});
            }
        };
        
        // Initialisation du jeu au chargement de la page
        window.onload = function() {
            window.initSnakeMatrix();
        }
    </script>
</body>
</html>